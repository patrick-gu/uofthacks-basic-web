<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>BASIC Web App</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"><script defer>/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nfunction execute(prog, ctx) {\n    while (ctx.ip < prog.statements.length) {\n        const stmt = prog.statements[ctx.ip];\n        let newIp = ctx.ip + 1;\n        switch (stmt.type) {\n            case \"assign\": {\n                const lvalue = resolveLvalue(ctx, stmt.lvalue);\n                const rvalue = evaluate(ctx, stmt.rvalue);\n                lvalue(clone(rvalue));\n                break;\n            }\n            case \"attribute\": {\n                const tag = ctx.currentTag;\n                if (tag.type === \"root\") {\n                    throw new Error(\"Can only add attributes when inside a tag.\");\n                }\n                tag.attributes.set(stmt.key, evaluate(ctx, stmt.value));\n                break;\n            }\n            case \"open\": {\n                const tag = {\n                    type: \"tag\",\n                    tag: stmt.tag,\n                    parent: ctx.currentTag,\n                    attributes: new Map(),\n                    bindings: new Map(),\n                    content: [],\n                };\n                ctx.currentTag.content.push(tag);\n                ctx.currentTag = tag;\n                break;\n            }\n            case \"close\": {\n                if (ctx.currentTag.type === \"root\") {\n                    throw new Error(\"No tag to close.\");\n                }\n                ctx.currentTag = ctx.currentTag.parent;\n                break;\n            }\n            case \"end\": {\n                render(prog, ctx, ctx.root);\n            }\n            case \"clear\": {\n                ctx.root = {\n                    type: \"root\",\n                    content: [],\n                };\n                ctx.currentTag = ctx.root;\n                break;\n            }\n            case \"goto\": {\n                newIp = stmt.statement;\n                break;\n            }\n            case \"print\": {\n                const value = evaluate(ctx, stmt.value);\n                const text = toString(value);\n                ctx.currentTag.content.push({\n                    type: \"text\",\n                    value: text,\n                });\n                break;\n            }\n            case \"gotoIf\": {\n                const cond = evaluate(ctx, stmt.cond);\n                if (cond.type === \"boolean\") {\n                    if (cond.value) {\n                        newIp = stmt.statement;\n                    }\n                }\n                else {\n                    throw new Error(`Cannot write condition of type ${stmt.type}.`);\n                }\n                break;\n            }\n            case \"dim\": {\n                const lvalue = resolveLvalue(ctx, stmt.lvalue);\n                const length = evaluate(ctx, stmt.length);\n                if (length.type !== \"number\") {\n                    throw new Error(\"Array length must be a number.\");\n                }\n                const arr = Array(length.value).map(() => ({\n                    type: \"number\",\n                    value: 0,\n                }));\n                const value = {\n                    type: \"array\",\n                    data: arr,\n                };\n                lvalue(value);\n                break;\n            }\n            case \"bind\": {\n                const lvalue = resolveLvalue(ctx, stmt.lvalue);\n                const tag = ctx.currentTag;\n                if (tag.type === \"root\") {\n                    throw new Error(\"Can only add bindings when inside a tag.\");\n                }\n                tag.bindings.set(stmt.key, lvalue);\n                break;\n            }\n            default: {\n                const _exhaustive = stmt;\n            }\n        }\n        ctx.ip = newIp;\n    }\n}\nfunction resolveLvalue(ctx, expr) {\n    if (expr.type === \"variable\") {\n        return (value) => {\n            ctx.variables.set(expr.variable, value);\n        };\n    }\n    else if (expr.type === \"arrayAccess\") {\n        const [array, index] = arrayIndex(ctx, expr.array, expr.index);\n        return (value) => {\n            array[index] = value;\n        };\n    }\n    else {\n        throw new Error(`Cannot assign to expression.`);\n    }\n}\nfunction evaluate(ctx, expr) {\n    switch (expr.type) {\n        case \"add\": {\n            const left = evaluate(ctx, expr.left);\n            const right = evaluate(ctx, expr.right);\n            if (left.type === \"number\" && right.type === \"number\") {\n                return {\n                    type: \"number\",\n                    value: left.value + right.value,\n                };\n            }\n            throw new Error(`Cannot add variables of type ${left.type} and ${right.type}`);\n        }\n        case \"callback\": {\n            return {\n                type: \"callback\",\n                line: expr.line,\n            };\n        }\n        case \"greater\": {\n            const left = evaluate(ctx, expr.left);\n            const right = evaluate(ctx, expr.right);\n            if (left.type !== \"number\" || right.type !== \"number\") {\n                throw new Error(`Can only compare numbers. Found ${left.type} > ${right.type}.`);\n            }\n            const value = left.value > right.value;\n            return {\n                type: \"boolean\",\n                value,\n            };\n        }\n        case \"equals\": {\n            const left = evaluate(ctx, expr.left);\n            const right = evaluate(ctx, expr.right);\n            return {\n                type: \"boolean\",\n                value: equals(left, right),\n            };\n        }\n        case \"literalBoolean\": {\n            return {\n                type: \"boolean\",\n                value: expr.value,\n            };\n        }\n        case \"literalInteger\": {\n            return {\n                type: \"number\",\n                value: expr.value,\n            };\n        }\n        case \"literalString\": {\n            return {\n                type: \"string\",\n                value: expr.value,\n            };\n        }\n        case \"variable\": {\n            const value = ctx.variables.get(expr.variable);\n            if (value === undefined) {\n                throw new Error(`Undefined variable ${expr.variable}`);\n            }\n            return value;\n        }\n        case \"modulo\": {\n            const left = evaluate(ctx, expr.left);\n            const right = evaluate(ctx, expr.right);\n            if (left.type === \"number\" && right.type === \"number\") {\n                if (right.value === 0) {\n                    throw new Error(\"Modulo by zero\");\n                }\n                return {\n                    type: \"number\",\n                    value: left.value % right.value,\n                };\n            }\n            throw new Error(`Cannot modulo variables of type ${left.type} and ${right.type}`);\n        }\n        case \"arrayAccess\": {\n            const [array, index] = arrayIndex(ctx, expr.array, expr.index);\n            return array[index];\n        }\n    }\n}\nfunction arrayIndex(ctx, arrayExpr, indexExpr) {\n    const array = evaluate(ctx, arrayExpr);\n    const index = evaluate(ctx, indexExpr);\n    if (array.type !== \"array\") {\n        throw new Error(`Cannot index non-array of type ${array.type}.`);\n    }\n    if (index.type !== \"number\") {\n        throw new Error(`Cannot index array with non-number type ${index.type}`);\n    }\n    if (!Number.isInteger(index.value) ||\n        !(0 <= index.value) ||\n        !(index.value < array.data.length)) {\n        throw new Error(`Index out of bounds: ${index.value}`);\n    }\n    return [array.data, index.value];\n}\nfunction equals(left, right) {\n    if (left.type !== right.type) {\n        return false;\n    }\n    switch (left.type) {\n        case \"boolean\":\n        case \"string\":\n        case \"number\": {\n            return (left.value === right.value);\n        }\n        case \"callback\": {\n            return left.line === right.line;\n        }\n        case \"array\": {\n            const lData = left.data;\n            const rData = right.data;\n            if (lData.length !== rData.length) {\n                return false;\n            }\n            for (let i = 0; i < lData.length; i++) {\n                if (!equals(lData[i], rData[i])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n}\nfunction toString(value) {\n    switch (value.type) {\n        case \"callback\":\n            return \"GOTO\" + value.line;\n        case \"number\":\n            return value.value.toString();\n        case \"string\":\n            return value.value;\n        case \"boolean\": {\n            if (value.value) {\n                return \"TRUE\";\n            }\n            else {\n                return \"FALSE\";\n            }\n        }\n        case \"array\": {\n            return \"(\" + value.data.map(toString).join(\",\") + \")\";\n        }\n    }\n}\nfunction clone(value) {\n    switch (value.type) {\n        case \"boolean\":\n        case \"number\":\n        case \"string\":\n        case \"callback\": {\n            return value;\n        }\n        case \"array\": {\n            return {\n                type: \"array\",\n                data: value.data.map(clone),\n            };\n        }\n    }\n}\nfunction render(prog, ctx, root) {\n    const body = getBody();\n    body.replaceChildren(...root.content.map((n) => renderNode(prog, ctx, n)));\n}\nfunction renderNode(prog, ctx, node) {\n    if (node.type === \"tag\") {\n        const res = document.createElement(node.tag);\n        for (const [key, value] of node.attributes.entries()) {\n            switch (value.type) {\n                case \"string\":\n                    res.setAttribute(key, value.value);\n                    break;\n                case \"number\":\n                case \"boolean\":\n                    res.setAttribute(key, value.value.toString());\n                    break;\n                case \"callback\":\n                    res[key] = () => {\n                        ctx.ip = value.line;\n                        execute(prog, ctx);\n                    };\n            }\n        }\n        res.onchange = (e) => {\n            for (const [key, value] of node.bindings.entries()) {\n                const v = e.target[key];\n                value({\n                    type: \"string\",\n                    value: v,\n                });\n            }\n        };\n        res.replaceChildren(...node.content.map((n) => renderNode(prog, ctx, n)));\n        return res;\n    }\n    else {\n        return node.value;\n    }\n}\nfunction getBody() {\n    const body = document.getElementsByTagName(\"body\")[0];\n    return body;\n}\n// import { voter } from \"./programs/voter\";\n// import { todos } from \"./programs/todos\";\nconst data_json_1 = __importDefault(__webpack_require__(/*! ../data/data.json */ \"./data/data.json\"));\nfunction main() {\n    const root = {\n        type: \"root\",\n        content: [],\n    };\n    const ctx = {\n        variables: new Map(),\n        ip: 0,\n        root,\n        currentTag: root,\n    };\n    execute(data_json_1.default, ctx);\n}\nwindow.addEventListener(\"DOMContentLoaded\", main);\n\n\n//# sourceURL=webpack://basic-web-runtime/./src/index.ts?");

/***/ }),

/***/ "./data/data.json":
/*!************************!*\
  !*** ./data/data.json ***!
  \************************/
/***/ ((module) => {

eval("module.exports = /*#__PURE__*/JSON.parse('{\"statements\":[{\"type\":\"assign\",\"lvalue\":{\"type\":\"variable\",\"variable\":\"len\"},\"rvalue\":{\"type\":\"literalInteger\",\"value\":0}},{\"type\":\"dim\",\"lvalue\":{\"type\":\"variable\",\"variable\":\"todos\"},\"length\":{\"type\":\"literalInteger\",\"value\":0}},{\"type\":\"assign\",\"lvalue\":{\"type\":\"variable\",\"variable\":\"next\"},\"rvalue\":{\"type\":\"literalString\",\"value\":\"\"}},{\"type\":\"goto\",\"statement\":13},{\"type\":\"dim\",\"lvalue\":{\"type\":\"variable\",\"variable\":\"cpy\"},\"length\":{\"type\":\"add\",\"left\":{\"type\":\"variable\",\"variable\":\"len\"},\"right\":{\"type\":\"literalInteger\",\"value\":1}}},{\"type\":\"assign\",\"lvalue\":{\"type\":\"variable\",\"variable\":\"i\"},\"rvalue\":{\"type\":\"literalInteger\",\"value\":0}},{\"type\":\"gotoIf\",\"cond\":{\"type\":\"equals\",\"left\":{\"type\":\"variable\",\"variable\":\"i\"},\"right\":{\"type\":\"variable\",\"variable\":\"len\"}},\"statement\":10},{\"type\":\"assign\",\"lvalue\":{\"type\":\"arrayAccess\",\"array\":{\"type\":\"variable\",\"variable\":\"cpy\"},\"index\":{\"type\":\"variable\",\"variable\":\"i\"}},\"rvalue\":{\"type\":\"arrayAccess\",\"array\":{\"type\":\"variable\",\"variable\":\"todos\"},\"index\":{\"type\":\"variable\",\"variable\":\"i\"}}},{\"type\":\"assign\",\"lvalue\":{\"type\":\"variable\",\"variable\":\"i\"},\"rvalue\":{\"type\":\"add\",\"left\":{\"type\":\"variable\",\"variable\":\"i\"},\"right\":{\"type\":\"literalInteger\",\"value\":1}}},{\"type\":\"goto\",\"statement\":6},{\"type\":\"assign\",\"lvalue\":{\"type\":\"variable\",\"variable\":\"todos\"},\"rvalue\":{\"type\":\"variable\",\"variable\":\"cpy\"}},{\"type\":\"assign\",\"lvalue\":{\"type\":\"arrayAccess\",\"array\":{\"type\":\"variable\",\"variable\":\"todos\"},\"index\":{\"type\":\"variable\",\"variable\":\"len\"}},\"rvalue\":{\"type\":\"variable\",\"variable\":\"next\"}},{\"type\":\"assign\",\"lvalue\":{\"type\":\"variable\",\"variable\":\"len\"},\"rvalue\":{\"type\":\"add\",\"left\":{\"type\":\"variable\",\"variable\":\"len\"},\"right\":{\"type\":\"literalInteger\",\"value\":1}}},{\"type\":\"assign\",\"lvalue\":{\"type\":\"variable\",\"variable\":\"i\"},\"rvalue\":{\"type\":\"literalInteger\",\"value\":0}},{\"type\":\"gotoIf\",\"cond\":{\"type\":\"equals\",\"left\":{\"type\":\"variable\",\"variable\":\"i\"},\"right\":{\"type\":\"variable\",\"variable\":\"len\"}},\"statement\":23},{\"type\":\"open\",\"tag\":\"p\"},{\"type\":\"open\",\"tag\":\"input\"},{\"type\":\"attribute\",\"key\":\"type\",\"value\":{\"type\":\"literalString\",\"value\":\"checkbox\"}},{\"type\":\"close\"},{\"type\":\"print\",\"value\":{\"type\":\"arrayAccess\",\"array\":{\"type\":\"variable\",\"variable\":\"todos\"},\"index\":{\"type\":\"variable\",\"variable\":\"i\"}}},{\"type\":\"close\"},{\"type\":\"assign\",\"lvalue\":{\"type\":\"variable\",\"variable\":\"i\"},\"rvalue\":{\"type\":\"add\",\"left\":{\"type\":\"variable\",\"variable\":\"i\"},\"right\":{\"type\":\"literalInteger\",\"value\":1}}},{\"type\":\"goto\",\"statement\":14},{\"type\":\"open\",\"tag\":\"input\"},{\"type\":\"bind\",\"key\":\"value\",\"lvalue\":{\"type\":\"variable\",\"variable\":\"next\"}},{\"type\":\"close\"},{\"type\":\"open\",\"tag\":\"button\"},{\"type\":\"attribute\",\"key\":\"onclick\",\"value\":{\"type\":\"callback\",\"line\":4}},{\"type\":\"print\",\"value\":{\"type\":\"literalString\",\"value\":\"Add\"}},{\"type\":\"close\"},{\"type\":\"end\"}]}');\n\n//# sourceURL=webpack://basic-web-runtime/./data/data.json?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;</script></head>
  <body>
  </body>
</html>